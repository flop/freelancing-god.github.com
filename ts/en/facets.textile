---
layout: ts_en
title: Facets
---

h2. Faceted Searching

Facet Searches are search summaries - they provide a breakdown of result counts for each of the defined categories/facets.

h3. Defining Facets

You define facets inside the *define_index* method, within your model. To specify that a field or attribute should be considered a facet, explicitly label it using the *:facet* symbol.

{% highlight ruby %}
define_index do
  # ...
  indexes author.name, :as => :author, :facet => true
  
  # ...
  has category_id, :facet => true
end
{% endhighlight %}

You _cannot_ use custom SQL statements as string facet sources. Thinking Sphinx is unable to interpret the SQL within the context of the model, and strings can't be stored as strings when they are attributes in Sphinx.

Even if you define your facet as a field, Thinking Sphinx duplicates it into an attribute, because facets are essentially grouped searches, and grouping can only be done with attributes.

h3. Querying Facets

Facets are available through the facets class method on all ActiveRecord models that have Sphinx indexes, and are returned as a subclass of Hash.

{% highlight ruby %}
Article.facets # =>
{
  :author => {
    "Sherlock Holmes" => 3,
    "John Watson"     => 10
  },
  :category_id => {
    12 => 4,
    42 => 7,
    47 => 2
  }
}
{% endhighlight %}

The facets method accepts the same options as the *search* method. When you use the *conditions* option, Thinking Sphinx will convert the field value into a CRC, and then use the *[field_name]_facet* attribute for grouping.

{% highlight ruby %}
Article.facets 'pancakes'
Article.facets :conditions => {:author => 'John Watson'}
Article.facets :with => {:author_facet => 'John Watson'.to_crc32} # same as previous
Artcile.facets :with => {:category_id => 12}
{% endhighlight %}

You can also explicitly request just certain facets:

{% highlight ruby %}
Article.facets :facets => [:author]
{% endhighlight %}

To retrieve the ActiveRecord object results based on a selected facet(s), you can use the *for* method on a facet search result. Note how #for only accepts the actual :field_name => 'value' pair, and not any other options.

{% highlight ruby %}
@facets = Article.facets('pancakes') # all facets with articles matching 'pancakes'
@articles = @facets.for # all articles matching 'pancakes'

@facets = Article.facets('detection', :facets => [:category_id]) # category_id facet options
@articles = @facets.for(:author => 'Sherlock Holmes') # all 'detection' articles with author 'Sherlock Holmes'
{% endhighlight %}

The alternate way of doing this would be to use both *search* and *facets* class methods.

{% highlight ruby %}
@articles = Article.search('detection', :with => {:author => 'Sherlock Holmes'}) # all 'detection' articles with author 'Sherlock Holmes'
@facets = Article.facets(@articles.options.merge(:facets => [:category_id], :with => {:author => nil}) # category_id facet options
{% endhighlight %}

h3. Global Facets

Faceted searches can be made across all indexed models, using the same arguments.

{% highlight ruby %}
ThinkingSphinx.facets 'pancakes'
{% endhighlight %}

By default, Thinking Sphinx does not request _all_ possible facets, only those common to all models. If you don't have any of your own facets, then this will just be the class facet, providing a summary of the matches per model.

{% highlight ruby %}
ThinkingSphinx.facets 'pancakes' # =>
{
  :class => {
    'Article' => 13,
    'User'    => 3,
    'Recipe'  => 23
  }
}
{% endhighlight %}

To disable the class facet, just set :class_facet to false.

{% highlight ruby %}
ThinkingSphinx.facets 'pancakes', :class_facet => false
{% endhighlight %}

And if you want absolutely every facet defined to be returned, whether or not they exist in all indexed models, set :all_facets to true.

{% highlight ruby %}
ThinkingSphinx.facets 'pancakes', :all_facets => true
{% endhighlight %}

h3. Displaying Facets

To get you started, here is a basic example displaying the facet options in a view:

{% highlight erb %}
<% @facets.each do |facet, facet_options| %>
  <h5><%= facet %></h5>
  <ul>
  <% facet_options.each do |option, count| %>
    <li><%= link_to "#{option} (#{count})", :overwrite_params => {facet => option, :page => 1} %></li>
  <% end %>
  </ul>
<% end %>
{% endhighlight %}

Thinking Sphinx does not sort facet results. One way to overcome this is to use Ruby's *sort*, or *sort_by* methods.

{% highlight ruby %}
@facets[:author].sort
@facets[:author].sort_by { |a| a[0] || '' } # catch options that are nil
@facets[:author].sort {|a,b| a[0].nil? ? -1 : b[0].nil? ? 1 : a[0] <=> b[0] } # same as above, using sort
{% endhighlight %}

